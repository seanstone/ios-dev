#!/usr/bin/env bash
set -euo pipefail

# --- Config / defaults ---
SDK="${IOS_SDK:-$(xcrun --sdk iphoneos --show-sdk-path)}"
CCBIN="${CCBIN:-clang}"

# --- Locate our own directory ---
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# iOS syscall shims (optional)
IOS_SYSCALLS_DIR="${IOS_SYSCALLS_DIR:-}"            # folder containing ios_syscalls.{h,c}

# Patch controls
PATCH_SCRIPT="${PATCH_SCRIPT:-${SCRIPT_DIR}/patch_macho.py}"
PATCH_ENABLED="${PATCH_ENABLED:-1}"                  # set 0 to skip patching
PATCH_TO_BUNDLE="${PATCH_TO_BUNDLE:-0}"              # set 1 to patch MH_BUNDLE instead of MH_DYLIB
PATCHED_SUFFIX="${PATCHED_SUFFIX:-}"         # output suffix for patched file

# Codesign controls (we sign the final artifact; patching invalidates signatures)
CODESIGN_ALLOWED="${CODESIGN_ALLOWED:-YES}"
ADHOC="${ADHOC:-0}"
CODESIGN_FLAGS="${CODESIGN_FLAGS:---timestamp=none --preserve-metadata=identifier,flags}"
ENTITLEMENTS="${ENTITLEMENTS:-}"

# Simulator vs Device detection
if [[ "${SDK}" == *"iPhoneSimulator"* ]] || [[ "${SDK}" == *"iphonesimulator"* ]]; then
  IS_SIM=1
else
  IS_SIM=0
fi

# --- Parse args: detect compile vs link; capture -o output ---
is_compile=0
out_file=""
prev=""
for a in "$@"; do
  [[ "$a" == "-c" ]] && is_compile=1
  if [[ "$prev" == "-o" ]]; then
    out_file="$a"
  fi
  prev="$a"
done

# --- Base compile flags ---
BASE_CFLAGS=( -target arm64-apple-ios -isysroot "$SDK" -fPIC )
if [[ -n "${IOS_SYSCALLS_DIR}" ]]; then
  BASE_CFLAGS+=( -include "${IOS_SYSCALLS_DIR}/ios_syscalls.h" )
fi

# Build ARGS from base flags + caller args
ARGS=( "${BASE_CFLAGS[@]}" "$@" )

# --- Pure compile step passthrough ---
if (( is_compile )); then
  exec "$CCBIN" "${ARGS[@]}"
fi

# --- Link step: ALWAYS produce a normal executable (MH_EXECUTE) ---
# Strip kind flags that fight with an executable
FILTERED_ARGS=()
skip_next=0
prev=""
for a in "$@"; do
  if (( skip_next )); then
    skip_next=0
    prev="$a"
    continue
  fi
  case "$a" in
    -dynamiclib|-bundle|-shared) ;;            # drop dylib/bundle requests
    -Wl,-dylib*)                 ;;            # drop any dylib-ish linker flags
    -install_name) skip_next=1 ;;              # drop install_name and its value
    -Wl,-pie|-pie) ;;                           # we'll add PIE explicitly below
    *) FILTERED_ARGS+=( "$a" );;
  esac
  prev="$a"
done
ARGS=( "${BASE_CFLAGS[@]}" "${FILTERED_ARGS[@]}" )

# Ensure PIE & sane defaults for iOS executables
EXEC_LINK_FLAGS=( -Wl,-pie )

# Optional: compile syscall shim once and include if present
TMPDIR="${TMPDIR:-/tmp}"
SYSCALLS_OBJ=""
SYSCALLS_C="${IOS_SYSCALLS_DIR}/ios_syscalls.c"
SYSCALLS_H="${IOS_SYSCALLS_DIR}/ios_syscalls.h"
if [[ -n "${IOS_SYSCALLS_DIR}" && -f "$SYSCALLS_C" && -f "$SYSCALLS_H" ]]; then
  SYSCALLS_OBJ="${TMPDIR%/}/ios_syscalls.o"
  if [[ ! -f "$SYSCALLS_OBJ" || "$SYSCALLS_C" -nt "$SYSCALLS_OBJ" || "$SYSCALLS_H" -nt "$SYSCALLS_OBJ" ]]; then
    "$CCBIN" -target arm64-apple-ios -isysroot "$SDK" -fPIC -c "$SYSCALLS_C" -o "$SYSCALLS_OBJ"
  fi
fi

# Perform the link (include shim object if present)
if [[ -n "$SYSCALLS_OBJ" && -f "$SYSCALLS_OBJ" ]]; then
  "$CCBIN" "${ARGS[@]}" "${EXEC_LINK_FLAGS[@]}" "$SYSCALLS_OBJ"
else
  "$CCBIN" "${ARGS[@]}" "${EXEC_LINK_FLAGS[@]}"
fi

# --- Post-link patch step (turn MH_EXECUTE -> MH_DYLIB or MH_BUNDLE) ---
# We patch the just-linked 'out_file' into 'patched_out' and sign that.
patched_out=""
if (( PATCH_ENABLED )); then
  if [[ -z "${out_file}" ]]; then
    echo "❌ Cannot run patch: output file not detected (-o missing)."
    exit 2
  fi
  if [[ ! -x "${PATCH_SCRIPT}" && ! -f "${PATCH_SCRIPT}" ]]; then
    echo "❌ PATCH_SCRIPT not found: ${PATCH_SCRIPT}"
    exit 2
  fi
  patched_out="${out_file}${PATCHED_SUFFIX}"
  if (( PATCH_TO_BUNDLE )); then
    python3 "${PATCH_SCRIPT}" "${out_file}" "${patched_out}" --to-bundle
  else
    python3 "${PATCH_SCRIPT}" "${out_file}" "${patched_out}"
  fi
else
  patched_out="${out_file}"
fi

# --- Codesign the final artifact (patched_out) ---
if [[ "${CODESIGN_ALLOWED}" == "YES" ]] && [[ -n "${patched_out}" ]]; then
  if [[ -n "${CODESIGN_IDENTITY:-}" ]]; then
    /usr/bin/codesign --force --sign "${CODESIGN_IDENTITY}" ${CODESIGN_FLAGS} \
      ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} \
      "${patched_out}"
  else
    if (( IS_SIM )) || (( ADHOC )); then
      /usr/bin/codesign --force --sign - ${CODESIGN_FLAGS} \
        ${ENTITLEMENTS:+--entitlements "$ENTITLEMENTS"} \
        "${patched_out}"
    else
      echo "⚠️  Skipping codesign: no CODESIGN_IDENTITY and not Simulator (set ADHOC=1 to force)."
    fi
  fi
else
  [[ -z "${patched_out}" ]] && echo "⚠️  Skipping codesign: patched output not determined."
  [[ "${CODESIGN_ALLOWED}" != "YES" ]] && echo "ℹ️  Codesign disabled (CODESIGN_ALLOWED=${CODESIGN_ALLOWED})."
fi

# Final note
echo "✅ Built executable: ${out_file}"
if (( PATCH_ENABLED )); then
  echo "✅ Patched to:      ${patched_out}"
fi
